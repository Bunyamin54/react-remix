## What is React?

React is a JavaScript library for building user interfaces. It follows a Component-based architecture and uses the concept of a Virtual DOM for efficient updates.

## MVC Pattern

Traditionally, UI frameworks use the MVC (Model, View, Controller) approach. In React, the focus is mostly on the View part.

Component Architecture
React applications are built from small, reusable components that represent parts of the UI.

## DOM vs Virtual DOM

DOM (Document Object Model): The browser’s representation of the webpage. Updating the real DOM directly can be slow.

Virtual DOM: React keeps a copy of the DOM in memory (a “virtual” version). When something changes, React updates the Virtual DOM first.

Shadow DOM: This is a different concept (used in Web Components), but React uses the Virtual DOM approach.

## How it works:

React keeps a copy of the DOM in memory (Virtual DOM).

When a change happens, React applies it to the Virtual DOM, not directly to the real DOM.

React uses a diffing algorithm to compare the Virtual DOM with the previous version.

Only the parts that actually changed are updated in the real DOM.

## Performance

This makes UI updates much faster because React avoids updating the entire DOM — it only updates what is necessary.
React does not specify exactly how often it updates; it depends on changes in the application. Since it is open source, the implementation details may evolve.


## Who uses React ?

Netflix 
Airbnb
Facebook
Uber
Udemy
Tweeter
Pinterest
Instegram

In Tr who uses? 

Trednyol 
Hepsiburada 


## React Starter

yarn create react-app my-app
yarn start 

..cd my-app
code .  // Direkt til Visual code

## If you want to add some packeges 

yarn add axios
yarn add bootstrap axios // to packages

yarn start

## Projeyi derleme

yarn install 
yarn start
yarn add tailwind react router. (birden fazla paket eklemek istersek)
yarn build -- derleme bundel islemi icin 
yarn test. - dosya adi 

## Component 

Componentler buyuk harfle baslar 

Component icerisnde js yi html i barindiran ve reacti barindiran bir yapi , Export ile disariye acilmis ve App js icinde cagrilmis bir yapi import ile

Self closing olarak kapanir <APP/> seklinde

SPA = singel page application demektir tum yapilar en sonunda onun altinda cagrilir 


Index,js baba gibi en sonunda cikis noktasi 
App,js Anne gibi derleyip toparlayan birlestiriyor childirinlari .

Bundel >>> dosyalarin tek bir dosyada toplanmasi anlamina geliyr  webpack , vit, percel  gibi araclar bundler dir. 

Export & Import mantigi ile calisir React 

HTML- markup demektir. JSX  JS+ XML = JSX 

<> <>= Fragment react da demektir

ES/ ile rafce ile kisaltamalr componentler hizlica otamatik olusturlur

## inline css key value seklinde   {/* inline css key- value notasyon olraka camelCase */}

1- style={{color: "red", backgroundColor: "blue" }}

2- property olarak da kullanabilirz  style={headerStyle}>


# Props - parametre demektir 

Tek yonlu olur Parentden /  Childe dogru Veri gonderme childe veri paylasimi

Child componente veri gonderme

## Props parentden childe bir tek yonlu bir veri akisi saglar... Nested yapi 

- React componentlerin bas harfi buyuk olur

Proplar tek yonludur- parentden childe gider siblingler arasi degismez, ortak parentden cekilir

Yukardan asagi dogru iletimine prop drilling denir. 

- best praksis closor isimleri kucuk harfle
- css dosyalari dogrudan import edilebiliyor. webpackden dolayi 
- for each return ozellig yoktur o yuzden cogu zaman biz map kullaniriz. 
{key} propu inherit bir props reactin icinde heryerde kullanilabilir. 

<> = Wrapper 

- Birden fazla statement kullaniclaksa o zaman fonksiyonun suslu {} ve return keywordu kullnamasi gerekir. 

## useState hook Events in React 
camelCase formatinda yazilir eventler 

onClick = {handleClick}. event handler dir.
Js alaninda function yazilir - return den once 

function parzantezli sekilde kullanilmaz 

- Reactin degismesi gereken seyleri State oluyor baslangicte hersey statik oluyor State ler ile Doma baislmasini yeniden basilmaisni Stateler ile saglariz. 

- Yeniden render edilmesini saglayan 2 sey 1-prop 2-state 
- State degisirse component render olur prop degisirse component render olur. 

- Aksi belirtilmedigi surece react statik olarak kabul eder herseyi manipulasyonlari azaltmak icin.

- State birseyleri interaktif sekilde basilmasini saglamak icin State kullaniriz. Dom da basilan interaktif olan nesneler icin State kullaniriz. 

## State

State kullanmanin 2 yontemi var 
- Class component artik cok kullanilmiyor. erisiren state this.state.count + 1. gibi this ile erisilir


## Hooks Built-in Hooks

useState
useEffect
useMemo
useRef

Baslangic degeri veriyoruz 

const [state, setState] = useState(initialState)

cosnt [counter,    setCounter]          = useState(0)
    ilk inidisi.   settermethods.       hook
    state degiskeni

Baslangic degeri // Primitiv veya //  Non primitiv olabilir. 

import {useState} from React dan import edebilriz 

- Bir Statetin degeri sadece setter ile olabilir. 

- State degisrse re render eder react ile algoritma degistigini anlar differens algoritmasi - degisenler dom a basilir. 

- //     {/* Eger setCount metodunu callback ile yazmazsak bu metot ilk acilistan itibaren doğrudan cagirilmis olur. Bu durumda da count state'inin gunceller. State guncellendigi icinde component re-render olur. Re-render ise yeninden setCount araciligi state'in guncellenmesine yol acar ve sonsuz donguye girer */}

- Hooklar use ile baslar 
- React componenti icinde kullanilir hooklar
- Hooklar ust seviyede kullanilir ana seviyesinde govdesinde kullanilir
- Custom hook da kullanabiliriz. 
- useState, useEffect, useContext


//* Hook Kullanim Kurallari:
//* 1. İlk olarak import edilmeliler. import { useState } from "react";
//* 2. Hook'lar ust seviyede kullanilmalidir. Yani Hook'lar bir
//*    dongunun, kosul cumleciginin ve icice fonksiyonlarin icerisinde
//*    kullanilmamalidir.
//* 3. Hook'lar sadece React Fonksiyonel componentleri icerisinde cagrilmalidir.
//*    Normal Javascript fonksiyonlari icerisinde cagrilmamalidir
//*    (Custom hook'lar icerisinde bir hook cagrilabilir)

Pur js icinde hook cagrilmaz
ancak ve ancak component veya baska bir hookun icinde cagrilabilir


## useReduser 
- ornegin bir suru stati birlestirip kontrol etmemize izin veren system 

- ayri ayri state kullanmak yerine obje kullanilabilir

## UseStateObject

... spread operatoru ile obje icerisini acariz...

- Bootstrap den aldigimiz form icerigini html to jsx e ceviren toollar ile cevirebiliriz hizlica 

- Obje formatina cevirirsek tek bir yerden kontrol edebiliyoruz. 

## UseEffect 

- Constructur - yapici funksiyon - 
this. ile ulasilir 

- Class component nasil olusturulur, React componentden turetilmsitiri 

- Yapici kurucu funksiyon  constructur baslangic degerini icinde alirlar ve this. ile erisilirler

- Class componenetlerde render() var  doma basilmaisni sagliyor. 

- setState methodu ile statei guncelliyoruz

//?                 LIFECYCLE METOTLARI
//?      https://reactjs.org/docs/react-component.html
//?=============================================================

//* Lifecycle metotlari componentlerin DOM'da varoldugu sure boyunca
//* uzerinde islem yapmamizi imkan saglayan ozel React metotlaridir.
//* Ornegin bir component olusturuldugunda, DOM'a basildiginda,
//* guncellendiginde veya DOM'dan kaldirildiginda bir seyler yapmak icin
//* lifecycle metotlari kullanilabilir.
//* En bilindik lifecycle metodu render() metodudur

//* Bir component'in olusturulmasi (constructor),
//* Bir componentin DOM agacina eklenmesinin hemen sonrasi(componentDidMount)
//* Bir component'in DOM'a basilmasi (render)
//* (Optional) Bir componentin guncellenmesinin hemen sonrasi (componentDidUpdate)
//* Bir component'in DOM agacindan kaldirilmasi sonrasi(componentWillUnmount)

# componentDidMount() {
    ilk render sonrasi calisir. 
    kodlari fetch() eder 
    doma basildiktan hemen sonrasi veri cekmek icin kullanilir

}

Clas componentlerde siralamasi 
- constructor(). kurulmasi anne karni buyumeye basla
- render().  --  doma tree ya basilmasi   cocugun buyumesi
- componentDidMount. -bir islem yapma kimlik karti cikartma / kulagina ezan okuma birkez yapildiginda 
   ilk renderdan hemen sonra claisir
   # Bir kereye mahsus seyler icin kullanilir ornek hava durumu network istegi
   # timer / interval baslatma ile ilgili islemler icin temel felsefesi budur. 

# Lifecycel methodlari aslinda developerlarin islerini kolaylastirmak icin gelistirmis methodlar yontemler

mounting - dogum. componentDidMount() 
updating - yasam.  componentDidUpdate()
unmounting - olum.  componentWillUnmout()

# componentDidUpdate(). state guncellendikten sonra kullanilir 
 - bir componentin state , propu degisirse guncellenme olursa sepet komponenti kullanic yen ibir urun ekledi , ilk render haricindeki sonraki her render dan sonra react bunu cagirir. 

 - cocuk dogduktan sonra 1 yasina girdi , dogum gunu partisi, her yil her yas guncellemesinden sonra yapilir. 

 - react ortaminda hava sicaklik verilerin getirdik , herbir saatte bir veriyi cekme, guncelleme. dolar/euro parimetresi ornegin yukselme olursa satis / dusus varsa al
 -kismen baglantili 

 ##  componentWillUnmout

  - sepeti kaldir
  - ekrandan kaldir
  - dom tree den kaldir

  - sonraki temizlik islemler icin kullanilir .
  - defin islemlerin yapildigi yerdir. 
  - nettwork isteklerinin iptal edilmesi gibi 

# Siralama
once constructor calisir 
sonra render claisir 

constructor run
render run
componentDidMount

==============================================
                USEEFFECT HOOK
// //?===============================================
// //! UseEffect Hook'u fonksiyonel componenler'te yan etkileri
// //! (side effect) gerceklestirmek icin kullanilir.
// //! componentDidMount,componentDidUpdate,ve componentWillUnmount
// //! metotlarinin bir birlesimi gibi dusunulebilir.

tek bir hook ile 3 fakrli islemei yapabiliyoruz . 

- didMount 
- didUpdate
- 
//! useEffect(() => {
//*   /* ComponentDidMount code */
//*      Kodlar
//! }, []);

//! useEffect(() => {
//*   */ ComponentDidMount + componentDidUpdate code */
//! }, [state1, state2]);

//! useEffect(() => {
//?   /* ComponentDidMount code */
//!   return () => {
//*     //* componentWillUnmount code */
//!   };
//! }, []);

//! useEffect(() => {
//*   //* componentDidMount code + componentDidUpdate code */

//!   return () => {
//*     //* componentWillUnmount code */
//!   };
//! }, [state1, state2]); //? Dependency Array

//   useEffect(() => {
//     //? componentDidMount (Dependency Array bos ise)
//     //? componentDidMount + componentDidUpdate (Dependency array bos degilse)
//     //? Dependecny array'Deki state her degistiginde veya ilk render sonrasi bu kod blogu tekrardan calistirilir.

//     return () => {
//       //? Cleanup function (componentWillUnmount)
//     }
//   }, [count]) //? Dependency Array

const UseEffectHook = () => {
  const [count, setCount] = useState(0)

  //!   ComponentDidMount
  //   useEffect(() => {
  //     //! fetch, async-await ,localStorage, setTimeout, setInterval();
  //     console.log("componentDidMount")
  //     setTimeout(() => {
  //       alert("Data fetched")
  //     }, 3000)
  //   }, []) //? Dependecny array bos

  //!   ComponentDidUpdate
  //   useEffect(() => {
  //     console.log("componentDidMount + componentDidUpdate")
  //     setTimeout(() => {
  //       alert("Data fetched")
  //     }, 3000)
  //   }, [count]) //? count state'i her degistiginde yukaridaki mount+update kismi calisitirilir.


# useEffect hooku

  useEffect(() => ){

    - componentDidMount + componentDidUpdate

    return () => {
   
    - componentWillUnmount 
    }
  }, [state,state2] // dependecy array bagimlilik arrayi   

  oldugunda state guncellendigi icin didMount + didUpdate de calisir. 
  return oldugu zamanda otamatik olarak willUnmount calisir. 

  # Fetch() icerisine url yazilir 


## Axios

Crud - islemleri 

GET - tum bilgileri almak istersen
put. - tum veriler degisir put isteginde 
patch
post silme islemi

postman gibi ortamlarda keylere tirnk konulur ""

 {
        
        "title": "Java Script",
        "description": "Stylesheet"
    }

- axios post islemi axios.post(url, {veriler}). bu sekilde 


## Router intro 

- ssr. / server side rendering.. 

- csr / client server rendergin (SPA) singel page applications - ilk loaading suresi artirabilir dezanvatj olarak - seo acisindan zayif 

- next.js de hem ssr - hem csr yapilabiliyor 

- path e gore conditinoal rendering sunuyor

- NavLink Link den farki styllendirme yapabilmesi 

# Rooter hooks 

- useNavigate
/ herhangi bir url yok demek 